import { Injectable, Logger } from '@nestjs/common'
import type { DataSource } from 'typeorm'

@Injectable()
export class DatabasePreSyncService {
  private readonly logger = new Logger(DatabasePreSyncService.name)

  constructor(private readonly dataSource: DataSource) {}

  /**
   * Nettoyage sp√©cialis√© avant la synchronisation TypeORM
   */
  async cleanBeforeSync(): Promise<void> {
    this.logger.log('üßπ Nettoyage pr√©-synchronisation...')

    try {
      // 1. Supprimer les index TypeORM sp√©cifiques probl√©matiques
      await this.removeKnownProblematicIndexes()

      // 2. Supprimer tous les index auto-g√©n√©r√©s par TypeORM
      await this.removeAutoGeneratedIndexes()

      // 3. Nettoyer les contraintes uniques orphelines
      await this.cleanOrphanedUniqueConstraints()

      // 4. V√©rifier qu'il n'y a plus d'index probl√©matiques
      await this.verifyNoProblematicIndexes()

      this.logger.log('‚úÖ Nettoyage pr√©-synchronisation termin√©')
    } catch (error) {
      this.logger.error('‚ùå Erreur lors du nettoyage pr√©-synchronisation:', error)
      throw error
    }
  }

  /**
   * Supprime les index sp√©cifiques connus pour √™tre probl√©matiques
   */
  private async removeKnownProblematicIndexes(): Promise<void> {
    const knownProblematicIndexes = [
      'IDX_e4a5a4bcd15ca9eedd81916638', // Index principal probl√©matique
      'IDX_97672ac88f789774dd47f7c8be3', // Autre index probl√©matique
      'UQ_e4a5a4bcd15ca9eedd81916638', // Contrainte unique associ√©e
      'UQ_97672ac88f789774dd47f7c8be3', // Autre contrainte unique
    ]

    for (const indexName of knownProblematicIndexes) {
      try {
        // V√©rifier si l'index existe
        const exists = await this.dataSource.query(
          `
          SELECT 1 FROM pg_indexes 
          WHERE indexname = $1 AND schemaname = 'public'
        `,
          [indexName]
        )

        if (exists.length > 0) {
          await this.dataSource.query(`DROP INDEX IF EXISTS "${indexName}" CASCADE`)
          this.logger.log(`‚úÖ Index sp√©cifique ${indexName} supprim√©`)
        }
      } catch (error) {
        this.logger.warn(
          `‚ö†Ô∏è  Impossible de supprimer l'index ${indexName}:`,
          error instanceof Error ? error.message : String(error)
        )
      }
    }
  }

  /**
   * Supprime tous les index auto-g√©n√©r√©s par TypeORM
   */
  private async removeAutoGeneratedIndexes(): Promise<void> {
    try {
      const autoGeneratedIndexes = await this.dataSource.query(`
        SELECT i.indexname, i.tablename
        FROM pg_indexes i
        JOIN pg_class c ON i.tablename = c.relname
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE i.schemaname = 'public'
        AND n.nspname = 'public'
        AND c.relkind = 'r'
        AND (
          (i.indexname LIKE 'IDX_%' AND length(i.indexname) BETWEEN 30 AND 34)
          OR (i.indexname LIKE 'UQ_%' AND length(i.indexname) BETWEEN 30 AND 34)
          OR (i.indexname LIKE 'FK_%' AND length(i.indexname) BETWEEN 30 AND 34)
        )
        AND i.indexname NOT IN (
          SELECT conname FROM pg_constraint 
          WHERE contype IN ('p', 'f') -- Exclure les cl√©s primaires et √©trang√®res
        )
      `)

      this.logger.log(`üîç ${autoGeneratedIndexes.length} index auto-g√©n√©r√©s trouv√©s`)

      for (const { indexname, tablename } of autoGeneratedIndexes) {
        try {
          await this.dataSource.query(`DROP INDEX IF EXISTS "${indexname}" CASCADE`)
          this.logger.log(`‚úÖ Index auto-g√©n√©r√© ${indexname} (table: ${tablename}) supprim√©`)
        } catch (error) {
          this.logger.warn(
            `‚ö†Ô∏è  Impossible de supprimer l'index ${indexname}:`,
            error instanceof Error ? error.message : String(error)
          )
        }
      }
    } catch (error) {
      this.logger.error('Erreur lors de la suppression des index auto-g√©n√©r√©s:', error)
    }
  }

  /**
   * Nettoie les contraintes uniques orphelines
   */
  private async cleanOrphanedUniqueConstraints(): Promise<void> {
    try {
      const orphanedConstraints = await this.dataSource.query(`
        SELECT c.conname, c.conrelid::regclass as table_name
        FROM pg_constraint c
        JOIN pg_class cl ON c.conrelid = cl.oid
        JOIN pg_namespace n ON cl.relnamespace = n.oid
        WHERE c.contype = 'u'
        AND n.nspname = 'public'
        AND cl.relkind = 'r'
        AND (
          (c.conname LIKE 'UQ_%' AND length(c.conname) BETWEEN 30 AND 34)
          OR c.conname IN (
            'UQ_e4a5a4bcd15ca9eedd81916638',
            'UQ_97672ac88f789774dd47f7c8be3'
          )
        )
      `)

      this.logger.log(`üîç ${orphanedConstraints.length} contraintes uniques orphelines trouv√©es`)

      for (const { conname, table_name } of orphanedConstraints) {
        try {
          await this.dataSource.query(`
            ALTER TABLE IF EXISTS ${table_name} 
            DROP CONSTRAINT IF EXISTS "${conname}" CASCADE
          `)
          this.logger.log(`‚úÖ Contrainte orpheline ${conname} supprim√©e`)
        } catch (error) {
          this.logger.warn(
            `‚ö†Ô∏è  Impossible de supprimer la contrainte ${conname}:`,
            error instanceof Error ? error.message : String(error)
          )
        }
      }
    } catch (error) {
      this.logger.error('Erreur lors du nettoyage des contraintes orphelines:', error)
    }
  }

  /**
   * V√©rifie qu'il n'y a plus d'index probl√©matiques
   */
  private async verifyNoProblematicIndexes(): Promise<void> {
    const problematicIndexes = await this.dataSource.query(`
      SELECT indexname, tablename
      FROM pg_indexes
      WHERE schemaname = 'public'
      AND indexname IN (
        'IDX_e4a5a4bcd15ca9eedd81916638',
        'IDX_97672ac88f789774dd47f7c8be3',
        'UQ_e4a5a4bcd15ca9eedd81916638',
        'UQ_97672ac88f789774dd47f7c8be3'
      )
    `)

    if (problematicIndexes.length > 0) {
      this.logger.error(`‚ùå ${problematicIndexes.length} index probl√©matiques persistent:`)
      problematicIndexes.forEach((idx: { indexname: string; tablename: string }) => {
        this.logger.error(`   - ${idx.indexname} sur ${idx.tablename}`)
      })
      throw new Error('Des index probl√©matiques persistent apr√®s le nettoyage')
    } else {
      this.logger.log('‚úÖ Aucun index probl√©matique d√©tect√©')
    }
  }

  /**
   * Supprime une table sp√©cifique si elle existe
   */
  async dropTableIfExists(tableName: string): Promise<void> {
    try {
      await this.dataSource.query(`DROP TABLE IF EXISTS "${tableName}" CASCADE`)
      this.logger.log(`‚úÖ Table ${tableName} supprim√©e`)
    } catch (error) {
      this.logger.warn(
        `‚ö†Ô∏è  Impossible de supprimer la table ${tableName}:`,
        error instanceof Error ? error.message : String(error)
      )
    }
  }

  /**
   * Supprime toutes les tables li√©es aux user_menu_preferences
   */
  async cleanUserMenuPreferencesTables(): Promise<void> {
    const relatedTables = [
      'user_menu_preferences_admin',
      'user_menu_preferences',
      'user_menu_item_preferences',
      'user_menu_item_preference',
    ]

    for (const tableName of relatedTables) {
      await this.dropTableIfExists(tableName)
    }
  }
}
