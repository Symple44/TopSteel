#!/usr/bin/env ts-node
/**
 * Script de nettoyage forc√© pour supprimer l'index probl√©matique
 * Usage: npm run db:force-cleanup
 */

import { DataSource } from 'typeorm'
import { Logger } from '@nestjs/common'
import * as dotenv from 'dotenv'
import * as path from 'path'

// Charger les variables d'environnement
dotenv.config({ path: path.join(__dirname, '../../../../.env.local') })

const logger = new Logger('ForceCleanup')

async function forceCleanupIndex() {
  const dataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    username: process.env.DB_USERNAME || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres',
    database: process.env.DB_NAME || 'erp_topsteel',
  })

  try {
    await dataSource.initialize()
    logger.log('‚úÖ Connexion √† la base de donn√©es √©tablie')

    // Supprimer directement l'index probl√©matique
    const problematicIndex = 'IDX_e4a5a4bcd15ca9eedd81916638'
    
    logger.log(`üî• Suppression forc√©e de l'index ${problematicIndex}`)
    
    // V√©rifier si l'index existe
    const indexExists = await dataSource.query(`
      SELECT 1 FROM pg_indexes 
      WHERE indexname = $1 
      AND schemaname = 'public'
    `, [problematicIndex])
    
    if (indexExists.length > 0) {
      logger.log(`üîç Index trouv√©, suppression en cours...`)
      
      // Supprimer l'index de force
      await dataSource.query(`DROP INDEX IF EXISTS "${problematicIndex}" CASCADE`)
      logger.log(`‚úÖ Index ${problematicIndex} supprim√© avec succ√®s`)
      
      // V√©rifier la suppression
      const stillExists = await dataSource.query(`
        SELECT 1 FROM pg_indexes 
        WHERE indexname = $1 
        AND schemaname = 'public'
      `, [problematicIndex])
      
      if (stillExists.length === 0) {
        logger.log(`‚úÖ Confirmation: l'index n'existe plus`)
      } else {
        logger.error(`‚ùå L'index persiste encore!`)
      }
    } else {
      logger.log(`‚ÑπÔ∏è  L'index n'existe pas dans la base`)
    }
    
    // Supprimer √©galement la table user_menu_preferences_admin si elle existe
    logger.log(`üî• Suppression forc√©e de la table user_menu_preferences_admin`)
    
    const tableExists = await dataSource.query(`
      SELECT 1 FROM information_schema.tables 
      WHERE table_name = 'user_menu_preferences_admin' 
      AND table_schema = 'public'
    `)
    
    if (tableExists.length > 0) {
      await dataSource.query(`DROP TABLE IF EXISTS "user_menu_preferences_admin" CASCADE`)
      logger.log(`‚úÖ Table user_menu_preferences_admin supprim√©e`)
    } else {
      logger.log(`‚ÑπÔ∏è  La table n'existe pas`)
    }
    
    // Supprimer tous les index TypeORM auto-g√©n√©r√©s
    logger.log(`üßπ Nettoyage des index auto-g√©n√©r√©s`)
    
    const autoGeneratedIndexes = await dataSource.query(`
      SELECT indexname
      FROM pg_indexes
      WHERE schemaname = 'public'
      AND indexname LIKE 'IDX_%'
      AND length(indexname) BETWEEN 30 AND 34
    `)
    
    for (const { indexname } of autoGeneratedIndexes) {
      try {
        await dataSource.query(`DROP INDEX IF EXISTS "${indexname}" CASCADE`)
        logger.log(`‚úÖ Index auto-g√©n√©r√© ${indexname} supprim√©`)
      } catch (error) {
        logger.warn(`‚ö†Ô∏è  Impossible de supprimer ${indexname}:`, error instanceof Error ? error.message : String(error))
      }
    }
    
    logger.log(`üéâ Nettoyage forc√© termin√© avec succ√®s!`)
    logger.log(`Vous pouvez maintenant red√©marrer l'application.`)
    
    await dataSource.destroy()
    process.exit(0)
  } catch (error) {
    logger.error('‚ùå Erreur lors du nettoyage forc√©:', error)
    process.exit(1)
  }
}

forceCleanupIndex()