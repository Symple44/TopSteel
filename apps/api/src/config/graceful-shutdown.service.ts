// apps/api/src/config/graceful-shutdown.service.ts
import { Injectable, Logger, OnApplicationShutdown } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import type { NestApplication } from '@nestjs/core'
import { EnhancedServerManager } from './enhanced-server-manager'

@Injectable()
export class GracefulShutdownService implements OnApplicationShutdown {
  private readonly logger = new Logger(GracefulShutdownService.name)
  private app: NestApplication
  private actualPort: number
  private shutdownInProgress = false

  constructor(private readonly configService: ConfigService) {}

  setApp(app: any, port: number) {
    this.app = app
    this.actualPort = port
  }

  async onApplicationShutdown(signal?: string) {
    if (this.shutdownInProgress) {
      this.logger.warn('Arr√™t d√©j√† en cours, ignorer le signal ' + signal)
      return
    }

    this.shutdownInProgress = true
    this.logger.log(`üîÑ D√©but de l'arr√™t gracieux (signal: ${signal})`)

    try {
      await this.performGracefulShutdown()
    } catch (error) {
      this.logger.error('‚ùå Erreur durant l\'arr√™t gracieux:', error)
      await this.forceShutdown()
    }
  }

  private async performGracefulShutdown(): Promise<void> {
    const shutdownTimeout = 30000 // 30 secondes max
    const startTime = Date.now()

    // 1. Arr√™ter d'accepter de nouvelles connexions
    this.logger.log('üìù 1/6 - Arr√™t des nouvelles connexions...')
    const server = this.app?.getHttpServer()
    
    if (server && server.listening) {
      await new Promise<void>((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout lors de la fermeture du serveur HTTP'))
        }, 10000)

        server.close((error) => {
          clearTimeout(timeout)
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        })
      })
      this.logger.log('‚úÖ Serveur HTTP ferm√©')
    }

    // 2. Attendre que les connexions existantes se terminent
    this.logger.log('üìù 2/6 - Attente de la fin des connexions actives...')
    await this.waitForActiveConnections(5000)

    // 3. Fermer les connexions de base de donn√©es
    this.logger.log('üìù 3/6 - Fermeture des connexions base de donn√©es...')
    try {
      if (this.app) {
        // Fermer les connexions TypeORM si pr√©sentes
        const dataSource = this.app.get('DataSource', { strict: false })
        if (dataSource && dataSource.isInitialized) {
          await dataSource.destroy()
          this.logger.log('‚úÖ Connexions base de donn√©es ferm√©es')
        }
      }
    } catch (error) {
      this.logger.warn('‚ö†Ô∏è  Erreur lors de la fermeture des BDD:', error)
    }

    // 4. Fermer les connexions Redis/Cache
    this.logger.log('üìù 4/6 - Fermeture des connexions cache...')
    try {
      // Fermer Redis si pr√©sent
      const redisService = this.app?.get('RedisService', { strict: false })
      if (redisService && typeof redisService.disconnect === 'function') {
        await redisService.disconnect()
        this.logger.log('‚úÖ Connexions Redis ferm√©es')
      }
    } catch (error) {
      this.logger.warn('‚ö†Ô∏è  Erreur lors de la fermeture Redis:', error)
    }

    // 5. Fermer l'application NestJS
    this.logger.log('üìù 5/6 - Fermeture de l\'application NestJS...')
    if (this.app) {
      await this.app.close()
      this.logger.log('‚úÖ Application NestJS ferm√©e')
    }

    // 6. Lib√©rer le port explicitement
    this.logger.log('üìù 6/6 - Lib√©ration du port...')
    if (this.actualPort) {
      await EnhancedServerManager.cleanupPort(this.actualPort, 2)
    }

    const shutdownTime = Date.now() - startTime
    this.logger.log(`‚úÖ Arr√™t gracieux termin√© en ${shutdownTime}ms`)
  }

  private async waitForActiveConnections(timeout: number): Promise<void> {
    const server = this.app?.getHttpServer()
    if (!server) return

    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        // @ts-ignore - Acc√®s aux connexions internes
        const connections = server._connections || 0
        if (connections === 0) {
          clearInterval(checkInterval)
          resolve()
        }
      }, 100)

      setTimeout(() => {
        clearInterval(checkInterval)
        this.logger.warn('‚ö†Ô∏è  Timeout atteint pour les connexions actives')
        resolve()
      }, timeout)
    })
  }

  private async forceShutdown(): Promise<void> {
    this.logger.warn('‚ö†Ô∏è  Passage en mode arr√™t forc√©')

    // Tuer le processus current de force
    if (this.actualPort) {
      await EnhancedServerManager.killProcessOnPort(this.actualPort)
    }

    // Nettoyer les processus orphelins
    await EnhancedServerManager.cleanupOrphanedProcesses()

    process.exit(1)
  }

  /**
   * Setup des handlers de signaux
   */
  setupSignalHandlers(): void {
    // SIGTERM (envoy√© par Docker, PM2, etc.)
    process.on('SIGTERM', () => {
      this.logger.log('üì° Signal SIGTERM re√ßu')
      this.onApplicationShutdown('SIGTERM')
    })

    // SIGINT (Ctrl+C)
    process.on('SIGINT', () => {
      this.logger.log('üì° Signal SIGINT re√ßu (Ctrl+C)')
      this.onApplicationShutdown('SIGINT')
    })

    // SIGUSR2 (utilis√© par nodemon)
    process.on('SIGUSR2', () => {
      this.logger.log('üì° Signal SIGUSR2 re√ßu (nodemon restart)')
      this.onApplicationShutdown('SIGUSR2')
    })

    // Exceptions non g√©r√©es
    process.on('uncaughtException', (error) => {
      this.logger.error('‚ùå Exception non captur√©e:', error)
      this.onApplicationShutdown('uncaughtException')
    })

    // Promesses rejet√©es non g√©r√©es
    process.on('unhandledRejection', (reason, promise) => {
      this.logger.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason)
      this.onApplicationShutdown('unhandledRejection')
    })

    // Windows - Ctrl+Break
    if (process.platform === 'win32') {
      process.on('SIGBREAK', () => {
        this.logger.log('üì° Signal SIGBREAK re√ßu (Windows)')
        this.onApplicationShutdown('SIGBREAK')
      })
    }
  }
}